# Happy Vibe 开发指南

## 项目概述

Happy Vibe 是一款将 **Vibe-Coding** 活动游戏化的养成类游戏。玩家通过真实的编程活动获得游戏内奖励，建设自己的虚拟家园。

---

## 一、技术架构总览

```
┌─────────────────────────────────────────────────────────────────┐
│                      Happy Vibe 技术栈                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【游戏客户端】                                                  │
│  ├── 引擎: Godot 4.2+                                           │
│  ├── 语言: GDScript                                             │
│  ├── 风格: 像素艺术 2D                                          │
│  └── 平台: Windows/Mac/Linux (Web后续)                          │
│                                                                 │
│  【本地服务】                                                    │
│  ├── 框架: FastAPI (Python)                                     │
│  ├── 数据库: SQLite (加密)                                      │
│  ├── 通信: HTTP + WebSocket                                     │
│  └── 监控: 系统托盘应用                                         │
│                                                                 │
│  【数据采集】                                                    │
│  ├── Claude Code: 日志文件监听                                  │
│  ├── Cursor: (计划中)                                           │
│  └── GitHub: API集成                                           │
│                                                                 │
│  【云端服务】(MVP后)                                             │
│  ├── 后端: FastAPI / Node.js                                    │
│  ├── 数据库: PostgreSQL + Redis                                 │
│  └── 部署: Docker + 云服务                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、项目结构

```
B:\study\AI\Happy-Vibe\
├── docs/                          # 项目文档
│   └── Spec-Driven-Development.md  # 完整设计文档
│
├── game/                          # Godot 游戏客户端
│   ├── project.godot/              # Godot 项目配置
│   │   ├── icon.png
│   │   └── export_presets.cfg      # 导出配置
│   │
│   ├── scenes/                    # 场景文件
│   │   ├── main/
│   │   │   ├── main_menu.tscn      # 主菜单
│   │   │   └── game_world.tscn     # 游戏世界
│   │   ├── farm/
│   │   │   ├── farm.tscn           # 农场场景
│   │   │   ├── plot.tscn           # 种植地块
│   │   │   └── building.tscn       # 建筑场景
│   │   └── ui/
│   │       ├── hud.tscn            # 游戏内HUD
│   │       ├── inventory.tscn      # 库存界面
│   │       └── achievement_popup.tscn
│   │
│   ├── scripts/                    # 脚本文件
│   │   ├── core/
│   │   │   ├── game_manager.gd     # 游戏管理器
│   │   │   ├── event_bus.gd        # 事件总线
│   │   │   └── save_manager.gd      # 存档管理
│   │   ├── player/
│   │   │   ├── player.gd           # 玩家角色
│   │   │   └── inventory.gd         # 库存系统
│   │   ├── farm/
│   │   │   ├── crop.gd             # 作物类
│   │   │   ├── plot.gd             # 地块类
│   │   │   └── farm_manager.gd      # 农场管理器
│   │   ├── vibe/
│   │   │   └── vibe_client.gd      # Vibe能量客户端
│   │   └── ui/
│   │       └── ...
│   │
│   ├── assets/                     # 资源文件
│   │   ├── sprites/                # 像素画
│   │   │   ├── player/
│   │   │   ├── crops/
│   │   │   ├── buildings/
│   │   │   └── ui/
│   │   ├── audio/
│   │   │   ├── sfx/                # 音效
│   │   │   └── music/              # 音乐
│   │   └── fonts/                  # 字体
│   │
│   └── addons/                     # 插件
│
├── vibehub/                       # VibeHub 本地服务
│   ├── src/
│   │   ├── main.py                 # 服务入口
│   │   ├── api/                    # API路由
│   │   │   ├── __init__.py
│   │   │   ├── player.py           # 玩家相关
│   │   │   ├── activity.py         # 活动相关
│   │   │   ├── farm.py             # 农场相关
│   │   │   └── achievement.py      # 成就相关
│   │   ├── core/                   # 核心逻辑
│   │   │   ├── activity_detector.py    # 活动检测
│   │   │   ├── energy_calculator.py    # 能量计算
│   │   │   ├── flow_detector.py         # 心流检测
│   │   │   └── quality_scorer.py        # 质量评分
│   │   ├── adapters/               # 数据源适配器
│   │   │   ├── base.py             # 基础适配器
│   │   │   ├── claude_code.py      # Claude Code
│   │   │   ├── cursor.py           # Cursor
│   │   │   └── github.py           # GitHub
│   │   ├── storage/                # 存储层
│   │   │   ├── database.py         # SQLite数据库
│   │   │   └── models.py           # 数据模型
│   │   └── utils/                  # 工具函数
│   │       ├── crypto.py           # 加密工具
│   │       └── logger.py           # 日志工具
│   ├── config/                     # 配置文件
│   │   ├── settings.py
│   │   └── logging.conf
│   ├── tests/                      # 测试
│   │   ├── test_adapter.py
│   │   └── test_calculator.py
│   ├── requirements.txt            # Python依赖
│   └── README.md
│
├── monitor/                       # 桌面监控器
│   ├── src/
│   │   ├── main.py                 # 监控器入口
│   │   ├── tray/                   # 系统托盘
│   │   ├── notify/                 # 通知系统
│   │   └── config/                 # 配置界面
│   └── build.yml                   # 构建配置
│
└── server/                        # 云服务 (可选)
    ├── api/                        # API服务
    ├── game/                       # 游戏逻辑
    ├── social/                     # 社交功能
    └── docker-compose.yml          # Docker配置
```

---

## 三、开发阶段详解

### Phase 0: 项目初始化 (1周)

**目标**: 搭建基础开发环境

```bash
# 1. 安装必要工具
# - Godot Engine 4.2+
# - Python 3.11+
# - Git
# - VS Code + 插件

# 2. 创建项目结构
# - 初始化Git仓库
# - 创建虚拟环境
# - 配置开发工具

# 3. 配置Godot项目
# - 创建新的Godot项目
# - 配置项目设置
# - 设置导入预设

# 4. 配置Python项目
# - 创建requirements.txt
# - 初始化FastAPI项目
# - 配置开发环境
```

### Phase 1: 技术验证 (2-4周)

**目标**: 验证核心技术可行性

#### 1.1 Claude Code数据采集验证

**实现方案：**

```
Claude Code 日志位置：
Windows: %USERPROFILE%\.claude\logs\
Mac: ~/Library/Application Support/Claude/logs/

日志格式分析：
- 会话日志: session-<date>.jsonl
- 包含: timestamp, role, content, tool_uses等

实现步骤：
1. 监听日志文件变化
2. 解析新行内容
3. 提取关键指标
4. 计算能量值
```

**代码框架：**

```python
# vibehub/src/adapters/claude_code.py
import os
import json
from datetime import datetime
from typing import AsyncIterator
from pathlib import Path

class ClaudeCodeAdapter:
    """Claude Code 数据适配器"""

    def __init__(self):
        self.log_path = self._get_log_path()
        self.last_position = 0

    def _get_log_path(self) -> Path:
        """获取Claude Code日志路径"""
        home = Path.home()
        if os.name == 'nt':  # Windows
            return home / '.claude' / 'logs'
        return home / 'Library' / 'Application Support' / 'Claude' / 'logs'

    def get_latest_session_file(self) -> Path:
        """获取最新的会话日志文件"""
        files = list(self.log_path.glob('session-*.jsonl'))
        if not files:
            return None
        return max(files, key=lambda p: p.stat().st_mtime)

    async def read_activities(self) -> AsyncIterator[dict]:
        """读取新的活动数据"""
        session_file = self.get_latest_session_file()
        if not session_file:
            return

        with open(session_file, 'r', encoding='utf-8') as f:
            f.seek(self.last_position)
            for line in f:
                try:
                    data = json.loads(line.strip())
                    yield self._parse_activity(data)
                except json.JSONDecodeError:
                    continue
            self.last_position = f.tell()

    def _parse_activity(self, data: dict) -> dict:
        """解析活动数据"""
        return {
            'timestamp': data.get('timestamp'),
            'role': data.get('role'),
            'content_length': len(data.get('content', '')),
            'tool_uses': data.get('tool_uses', []),
            'type': self._detect_activity_type(data)
        }

    def _detect_activity_type(self, data: dict) -> str:
        """检测活动类型"""
        tool_uses = data.get('tool_uses', [])
        if data.get('role') == 'user':
            return 'prompt'
        elif tool_uses:
            return 'tool_use'
        return 'response'
```

#### 1.2 能量计算验证

```python
# vibehub/src/core/energy_calculator.py
from datetime import datetime, timedelta

class EnergyCalculator:
    """Vibe能量计算器"""

    BASE_RATE = 10  # 每分钟基础能量
    MAX_TIME_BONUS = 2.0  # 最大时间加成
    MAX_QUALITY_BONUS = 1.5  # 最大质量加成
    FLOW_BONUS = 1.5  # 心流状态加成

    def calculate(self, activity: dict) -> dict:
        """计算活动获得的能量"""
        duration_minutes = activity.get('duration', 0)
        if duration_minutes == 0:
            return {'energy': 0, 'exp': 0, 'flow': False}

        # 基础能量
        base_energy = duration_minutes * self.BASE_RATE

        # 时间加成
        time_bonus = self._calculate_time_bonus(duration_minutes)

        # 质量加成
        quality_score = self._calculate_quality_score(activity)
        quality_bonus = 0.5 + quality_score * 0.5

        # 心流状态
        is_flow = self._detect_flow_state(activity)
        flow_bonus = self.FLOW_BONUS if is_flow else 1.0

        # 最终能量
        final_energy = int(base_energy * time_bonus * quality_bonus * flow_bonus)

        return {
            'energy': final_energy,
            'exp': final_energy // 10,
            'flow': is_flow,
            'breakdown': {
                'base': base_energy,
                'time_bonus': time_bonus,
                'quality_bonus': quality_bonus,
                'flow_bonus': flow_bonus
            }
        }

    def _calculate_time_bonus(self, duration_minutes: float) -> float:
        """计算时间加成"""
        bonus = 1.0 + (duration_minutes / 60) * 0.1
        return min(bonus, self.MAX_TIME_BONUS)

    def _calculate_quality_score(self, activity: dict) -> float:
        """计算质量评分 (0-1)"""
        score = 0.5

        # 成功率加成
        success_rate = activity.get('success_rate', 0.8)
        score += min(success_rate * 0.2, 0.2)

        # 工具多样性加成
        tool_variety = min(activity.get('tool_variety', 0) * 0.025, 0.1)
        score += tool_variety

        return min(score, 1.0)

    def _detect_flow_state(self, activity: dict) -> bool:
        """检测心流状态"""
        return (
            activity.get('duration', 0) >= 45 and  # 连续45分钟
            activity.get('interaction_gap', 0) < 5 * 60 and  # 交互间隔<5分钟
            activity.get('success_rate', 0) > 0.8  # 成功率>80%
        )
```

#### 1.3 本地API验证

```python
# vibehub/src/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .api import player, activity, farm
from .core.energy_calculator import EnergyCalculator

app = FastAPI(
    title="Happy Vibe Hub",
    description="Vibe-Coding 游戏化平台本地服务",
    version="0.1.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(player.router, prefix="/api/player", tags=["player"])
app.include_router(activity.router, prefix="/api/activity", tags=["activity"])
app.include_router(farm.router, prefix="/api/farm", tags=["farm"])

@app.get("/api/health")
async def health_check():
    return {"status": "ok", "version": "0.1.0"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8765)
```

### Phase 2: MVP核心开发 (2-3个月)

#### 2.1 Godot游戏客户端开发

**核心脚本框架：**

```gdscript
# game/scripts/core/game_manager.gd
extends Node

signal energy_changed(value: int)
signal exp_changed(value: int)
signal level_up(new_level: int)

var player_data: Dictionary = {}
var vibe_client: HTTPRequest = null

func _ready() ->
    load_player_data()
    setup_vibe_client()

func load_player_data():
    """加载玩家数据"""
    var save_file = FileAccess.open("user://player.dat", FileAccess.READ)
    if save_file:
        player_data = save_file.get_var()
        save_file.close()
    else:
        player_data = create_default_player()

func create_default_player() -> Dictionary:
    """创建默认玩家数据"""
    return {
        "username": "Player",
        "level": 1,
        "exp": 0,
        "energy": 100,
        "max_energy": 1000,
        "gold": 500,
        "diamonds": 0,
        "farm": {
            "plots": [],
            "buildings": []
        },
        "achievements": [],
        "stats": {
            "total_energy_earned": 0,
            "total_coding_time": 0
        }
    }

func add_energy(amount: int):
    """添加能量"""
    player_data.energy = min(player_data.energy + amount, player_data.max_energy)
    player_data.stats.total_energy_earned += amount
    energy_changed.emit(player_data.energy)
    save_player_data()

func add_exp(amount: int):
    """添加经验值"""
    player_data.exp += amount
    var exp_needed = calculate_exp_needed(player_data.level)
    if player_data.exp >= exp_needed:
        level_up()
    exp_changed.emit(player_data.exp)
    save_player_data()

func level_up():
    """升级"""
    player_data.exp -= calculate_exp_needed(player_data.level)
    player_data.level += 1
    player_data.max_energy = 1000 + (player_data.level * 100)
    level_up.emit(player_data.level)

func calculate_exp_needed(level: int) -> int:
    """计算升级所需经验"""
    return int(100 * level * (1 + level / 10.0))

func save_player_data():
    """保存玩家数据"""
    var save_file = FileAccess.open("user://player.dat", FileAccess.WRITE)
    save_file.store_var(player_data)
    save_file.close()
```

#### 2.2 作物系统

```gdscript
# game/scripts/farm/crop.gd
class_name Crop
extends Node2D

@export var crop_type: String = "variable_grass"
@export var growth_time: float = 3600  # 秒
@export var quality: int = 1  # 1-4

var planted_time: float = 0
var is_ready: bool = false
var growth_progress: float = 0.0

signal crop_ready(crop: Crop)
signal growth_changed(progress: float)

func _ready():
    planted_time = Time.get_unix_time_from_system()

func _process(delta):
    if not is_ready:
        update_growth()

func update_growth():
    """更新生长进度"""
    var current_time = Time.get_unix_time_from_system()
    var elapsed = current_time - planted_time
    growth_progress = min(elapsed / growth_time, 1.0)
    growth_changed.emit(growth_progress)

    if growth_progress >= 1.0 and not is_ready:
        is_ready = true
        crop_ready.emit(self)

func harvest() -> Dictionary:
    """收获作物"""
    var base_value = get_base_value()
    var quality_multiplier = get_quality_multiplier()
    var final_value = int(base_value * quality_multiplier)

    return {
        "type": crop_type,
        "quality": quality,
        "value": final_value
    }

func get_base_value() -> int:
    """获取基础价值"""
    var values = {
        "variable_grass": 10,
        "function_flower": 50,
        "class_tree": 200,
        "api_orchid": 150
    }
    return values.get(crop_type, 10)

func get_quality_multiplier() -> float:
    """获取品质倍数"""
    var multipliers = {1: 1.0, 2: 1.5, 3: 2.5, 4: 5.0}
    return multipliers.get(quality, 1.0)
```

---

## 四、关键技术实现

### 4.1 Claude Code日志监听

```
Claude Code 日志格式示例：
{
  "timestamp": "2025-01-15T10:30:00Z",
  "role": "user",
  "content": "帮我创建一个新的Python项目",
  "model": "claude-sonnet-4-5-20250929",
  "tool_uses": [
    {"name": "write", "input": {"file_path": "..."}},
    {"name": "bash", "input": {"command": "..."}}
  ]
}

关键指标提取：
- timestamp: 时间戳
- role: user/assistant
- tool_uses: 工具使用记录
- content: 内容长度
```

### 4.2 心流状态检测

```
心流状态判定条件（需同时满足）：
1. 连续编码时长 >= 45分钟
2. 交互间隔 < 5分钟（无长时间停顿）
3. 成功率 > 80%
4. 工具使用活跃（至少3种不同工具）
5. 代码产出 > 阈值

实现方式：
- 维护一个会话状态机
- 实时计算各项指标
- 综合判断心流状态
```

### 4.3 本地-游戏通信

```
通信架构：

游戏客户端 (Godot)
    │
    │ HTTP/WebSocket
    ▼
VibeHub (FastAPI) :8765
    │
    │ 文件读取
    ▼
Claude Code 日志

API端点：
POST /api/activity/start   - 开始活动追踪
POST /api/activity/update   - 更新活动进度
POST /api/activity/end      - 结束活动并获取奖励
GET  /api/player            - 获取玩家状态
```

---

## 五、开发工具配置

### 5.1 Godot项目配置

```ini
# game/project.godot/editor_settings-4.tres
[editor]
run/main_scene="res://scenes/main/main_menu.tscn"

[display]
window/size/viewport_width=1280
window/size/viewport_height=720
window/size/resizable=true

[rendering]
textures/canvas_textures/default_texture_filter=0

[input]
ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"keycode":4194314,"physical_keycode":0,"key_label":0,"unicode":0,"echo":false,"script":null)
]
}
```

### 5.2 Python依赖

```txt
# vibehub/requirements.txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
pydantic-settings==2.1.0
sqlalchemy==2.0.25
aiosqlite==0.19.0
websockets==12.0
python-multipart==0.0.6
pystray==0.19.5
plyer==2.1.0
cryptography==41.0.7
python-dotenv==1.0.0
```

---

## 六、快速开始

### 6.1 环境准备

```bash
# 1. 克隆/初始化项目
cd B:\study\AI\Happy-Vibe

# 2. 创建Python虚拟环境
python -m venv venv
venv\Scripts\activate  # Windows
# source venv/bin/activate  # Mac/Linux

# 3. 安装依赖
cd vibehub
pip install -r requirements.txt

# 4. 启动VibeHub服务
python src/main.py
# 服务运行在 http://127.0.0.1:8765

# 5. 打开Godot项目
# 启动Godot，打开 game/ 目录
```

### 6.2 API测试

```bash
# 健康检查
curl http://127.0.0.1:8765/api/health

# 获取玩家信息
curl http://127.0.0.1:8765/api/player

# 开始活动
curl -X POST http://127.0.0.1:8765/api/activity/start \
  -H "Content-Type: application/json" \
  -d '{"source": "claude_code"}'
```

---

## 七、开发检查清单

### Phase 0 - 项目初始化
- [x] 创建项目目录结构
- [x] 初始化Git仓库
- [ ] 配置Godot项目
- [x] 配置Python虚拟环境 (uv)
- [x] 编写README.md

### Phase 1 - 技术验证
- [x] VibeHub服务框架完成 (FastAPI + 健康检查API, 测试覆盖87%)
- [x] Claude Code日志解析实现 (适配器模块, 32个测试用例, 覆盖率95%)
- [ ] 能量计算算法实现
- [ ] 心流检测实现
- [ ] 本地API端点可用
- [ ] Godot基础场景创建
- [ ] Godot与VibeHub通信验证

### Phase 2 - MVP核心
- [ ] 玩家数据系统
- [ ] 农场场景
- [ ] 种植/收获系统
- [ ] 能量获取集成
- [ ] 基础成就系统
- [ ] UI界面完善
- [ ] 存档系统

---

## 八、常见问题

**Q: Claude Code日志路径在哪？**
A:
- Windows: `%USERPROFILE%\.claude\logs\`
- Mac: `~/Library/Application Support/Claude/logs/`

**Q: 如何验证能量计算是否正确？**
A: 使用测试工具模拟活动数据，检查返回的能量值

**Q: Godot如何与Python服务通信？**
A: 使用HTTPRequest节点调用HTTP API

**Q: 数据存储在哪？**
A: MVP阶段使用本地SQLite，用户数据存储在`user://`目录

---

## 九、下一步行动

1. **立即开始**: 执行Phase 0项目初始化
2. **技术验证**: 完成Claude Code数据采集原型
3. **迭代开发**: 按照Phase规划逐步推进
4. **持续测试**: 每个阶段完成后进行验证

